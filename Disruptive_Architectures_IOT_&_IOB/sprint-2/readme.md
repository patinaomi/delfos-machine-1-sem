
# Projeto

# Nossa solução

## Prevenir é CUIDAR: Cliente SEGURO, Parceiro RENTÁVEL.

Essa frase reflete o foco na prevenção para garantir a saúde do cliente, ao mesmo tempo em que destaca o impacto positivo nos parceiros (clínicas), trazendo mais eficiência e redução de custos. cliente na rua, é um cliente seguro e com saúde.
Falamos na rua, pois queremos atender 100% da carteira de cliente, para que todos façam consultas preventivas, evitando e previnindo 
consultas emegências, que podem acarretar altos custos.

## Video do Projeto
Também disponibilizamos um vídeo no YouTube demonstrando nossa solução e explicando as principais funcionalidades do projeto. Você pode assisti-lo através do seguinte link: [Link do Video no Youtube](https://youtu.be/CjscKHcfp7c)

## Objetivo

Nosso objetivo é reduzir os altos custos de sinistros, sem evitar consultas, mas sim prevenindo consultas de valores elevados e fora do comum.  Ao incentivar consultas preventivas, economizaremos recursos e diminuiremos a necessidade de atendimentos emergenciais.

Nosso modelo vai sugerir consultas ao cliente com base em suas preferências de atendimento, como local, data, horário, com especialistas que possuem qualidade acima de nota 4 e com custos baixos. Iremos treinar a IA para procurar o cliente primeiro, 
ao invés de esperar que ele nos procure com problemas maiores.

Por exemplo, se uma pessoa realiza limpezas e radiografias ósseas a cada 5 ou 6 meses, pode evitar extrações devido a cuidados bucais inadequados, que podem custar cerca de dois mil reais. Em nosso cenário, esse valor é extremamente alto. É mais vantajoso cobrir uma consulta de 200 reais, que representa apenas 10% do custo de um procedimento emergencial.

Além disso, vamos atender as clínicas e parceiros, levando mais clientes e aumentando sua carteira.

## Objetivos específicos

1. Reduz custos de sinistros: A solução ajuda a identificar clientes que podem precisar de cuidados preventivos e sugere consultas personalizadas, evitando o surgimento de problemas maiores e mais caros.

2. Automatiza a prevenção: Ao usar IA para sugerir consultas preventivas com base nas preferências dos clientes, o sistema evita a espera passiva por problemas emergenciais e passa a atuar de forma proativa, ajudando Mariana a controlar melhor os gastos.

3. Garante atendimento de qualidade: A solução só sugere especialistas com notas acima de 4 e custos mais baixos, mantendo a satisfação dos clientes e garantindo cuidados de qualidade.

4. Fortalece a rede de parceiros: Além de beneficiar os clientes, a solução leva mais pacientes para as clínicas parceiras, o que ajuda a aumentar a receita dessas instituições, mantendo-as engajadas com a operadora.

## Persona
**Essa situação vai explicar exatamente o que queremos e porque desejamos criar esssa solução**

**Persona**
Persona: Claudio Delfos
Idade: 30 anos
Profissão: Desenvolvedor de software e estudante
Localização: São Paulo, SP
Perfil: Ativo, trabalha em período integral e estuda à noite, além de participar de projetos extracurriculares em tecnologia
Tempo de Convênio: 10 meses

**Sobre Claudio**
Claudio tem uma vida corrida, dividindo seu tempo entre o trabalho, os estudos e projetos pessoais. Ele valoriza muito a conveniência e eficiência em qualquer serviço que utilize, pois seu tempo livre é bastante limitado. Embora ele tenha um plano de saúde, não costuma usá-lo para consultas preventivas. Nos últimos dois meses, começou a sentir dores ao mastigar, mas nada que pareça sério o suficiente para levá-lo a marcar uma consulta por conta própria.

**Desafios e Frustrações**

***Falta de tempo para marcar consultas***

Claudio tem uma rotina apertada e acha difícil encontrar tempo para agendar e ir a consultas médicas, principalmente porque considera incômoda a necessidade de organizar essas visitas em meio a sua agenda já cheia.

***Problemas ignorados por falta de urgência*** 

Mesmo com um plano de saúde, Claudio evita ir ao médico até que o problema se torne mais sério, pois não quer perder tempo com consultas que julga desnecessárias no momento.

***Preocupação com a qualidade do atendimento*** 

Quando Claudio finalmente decide ir a uma consulta, ele se preocupa em encontrar um bom especialista, já que não quer perder tempo e dinheiro com atendimentos de baixa qualidade.

**Objetivos para o cliente**

***Resolver o problema de saúde sem interrupções em sua rotina**

Claudio gostaria de tratar sua dor ao mastigar antes que se torne algo mais grave, mas sem ter que reorganizar toda sua agenda.

***Ter acesso a um atendimento de qualidade e conveniente***

Ele quer um especialista confiável, que possa resolver o problema, sem precisar passar por vários profissionais diferentes ou arriscar receber um atendimento ruim.

**Como a solução atende às necessidades de Claudio**

"Prevenir é Cuidar: Cliente Seguro, Parceiro Rentável" oferece uma solução perfeita para Claudio, pois:

***Sugere consultas preventivas no melhor horário e local*** 

Claudio não precisa se preocupar em procurar e agendar consultas. A solução sugere automaticamente um especialista qualificado, em horários que se ajustam perfeitamente à sua agenda, tornando o processo muito mais conveniente. Hoje as empresas que foram pesquisadas, possuem ótimos aplicativos, mas todos os cliente precisa procurar e agendar.

***Previne o agravamento de problemas*** 

Mesmo com sua dor ainda moderada, a solução ajuda Claudio a agir antes que o problema se torne algo mais sério, evitando procedimentos mais caros e invasivos no futuro. Se ele for a consulta, o custo hoje pode ser em torno de 120,00 (pesquisa de mercado para os valores bases de uma simples consulta). O Especilista analisa seu caso, faz uma limpeza, e percebe que é só uma inflamação que pode ser tratado com antibiótico. Se o problema continuasse e o Claudio não tivesse tomado o remédio, ele teria que retirar um dente, o que custaria para a empresa uma valor base de 2200,00.

O que é Rentável nesta situação?

***Foca em qualidade de atendimento*** 

Claudio pode confiar nos especialistas sugeridos pela plataforma, sabendo que todos têm notas altas, o que reduz o risco de uma má experiência e aumenta sua confiança no tratamento. Além dos Especilistas que vão ficar satisfeito com a Delfos Machine, por propor um novo cliente recorrente a sua carteira de clientes. Trazendo grana e cuidado da empresa com sua clinica parceira.

Sem mencionar que ambos vão ganhar no programa de benefício, que pode gerar produtos, descontos e fidelidade com a OdontoPrev.


## Etapas do projeto

Para atender à demanda da OdontoPrev, o projeto será dividido em seis fases principais, com cada fase sendo complementada pelos arquivos betas enviados e pelos requisitos descritos.

**Fase 1: Conexão com o Banco de Dados**

Objetivo: Estabelecer uma conexão segura e estável com o banco de dados da OdontoPrev.

Descrição:
Implementar um sistema de autenticação para garantir acesso controlado, utilizando login e senha.
Integrar a aplicação ao banco de dados, utilizando credenciais e parâmetros fornecidos pela OdontoPrev.
Utilizar a biblioteca pandas para carregar e manipular os dados diretamente a partir do banco, permitindo consultas e atualizações.
Tecnologias: Python, SQLAlchemy (ou outra biblioteca de ORM), Pandas, Banco de Dados (Oracle, MySQL, etc.)

**Fase 2: Tratamento e Limpeza de Dados**

**Objetivo:** Preparar os dados provenientes do banco de dados para as fases subsequentes do projeto.

**Descrição:**

Carregar os dados utilizando pandas.
Realizar o tratamento de valores nulos, padronização de formatos, e correção de erros nos dados.
Realizar análises exploratórias iniciais para identificar padrões, outliers e outras informações importantes para as próximas etapas.

***Tecnologias: Python, Pandas, Numpy***

**Fase 3: Modelo de Análise de Sentimento dos Feedbacks**

**Objetivo:** Desenvolver um modelo para analisar o sentimento dos feedbacks recebidos pelos clientes.

**Descrição:**

Coletar e processar os dados de feedbacks armazenados no banco de dados.
Utilizar técnicas de processamento de linguagem natural (NLP) para treinar um modelo de análise de sentimento.
Classificar os feedbacks como positivos, negativos ou neutros.
Testar e ajustar o modelo para garantir a precisão desejada.

***Tecnologias: Python, NLTK (ou Spacy), Scikit-learn, Pandas***

**Fase 4: Modelo de Sugestão de Consultas**

**Objetivo:** Implementar um sistema de recomendação para sugerir consultas preventivas baseadas em dados de clientes.

**Descrição:**

Utilizar os dados dos clientes e históricos de consultas para sugerir automaticamente novas consultas preventivas.
O modelo deve levar em consideração preferências de horário, dia da semana, e a disponibilidade de especialistas e clínicas.
Implementar algoritmos de recomendação, como filtragem colaborativa ou baseada em conteúdo, para gerar as sugestões.

***Tecnologias: Python, Scikit-learn, Pandas, Algoritmos de Recomendação***

**Fase 5: Geração de Gráficos e Visualização de Dados**

**Objetivo:** Fornecer uma visão clara e visual do desempenho do modelo e dos dados utilizados no projeto.

**Descrição:**

Gerar gráficos e relatórios a partir dos dados tratados e dos resultados do modelo de sentimento e de sugestões.
Utilizar bibliotecas de visualização para criar gráficos interativos e relatórios claros que ajudem a entender os números reais do projeto.
Possíveis gráficos incluem: gráficos de barras, pizza, linha do tempo de consultas sugeridas, e análise de sentimentos.

***Tecnologias: Python, Matplotlib, Seaborn, Plotly, Power BI (se necessário)***

**Fase 6: Desenvolvimento e Implementação da API**

**Objetivo:** Criar uma API RESTful para integrar o sistema com outros projetos e permitir a utilização dos dados e modelos em diferentes aplicações.

**Descrição:**

Desenvolver uma API que permite a consulta e sugestão de consultas, além de obter os resultados da análise de sentimento.
A API deve ser segura, eficiente e escalável, atendendo aos padrões da OdontoPrev.
Implementar endpoints para facilitar o acesso aos dados e ao modelo de recomendação.

***Tecnologias: Python, Flask ou FastAPI, SQLAlchemy, Docker (para deploy se necessário)***

## Detalhes das Etapas

**Coletar Dados do Cliente**
Utilizar o formulário de cadastro para coletar informações como localização preferida pelo cliente, avaliações de satisfação das clinicas e médicos, além dos valores de consultas com preco acessível. Na solução apresentada, se tiver qualidade, mostra que mesmo com custo baixo, a consulta pode atender a necessidade do cliente.

***O que será feito - Oracle***
Essas informações já estão no banco de dados, para coletar elas, usaremos a bilioteca do Oracle para conectar no banco e criar um dataframe.

```bash
    import oracledb
    
    # Minhas credenciais
    credencial_banco = {
        'dsn': 'oracle.fiap.com.br:1521/orcl',
        'usuario': 'rm553472',
        'senha': '100593'
    }

    # Função para conectar ao banco de dados
    def conectar(usuario, senha, dsn):
        try:
            conexao = oracledb.connect(user=usuario, password=senha, dsn=dsn, mode=oracledb.DEFAULT_AUTH)
            print("Conexão com o banco de dados Oracle estabelecida com sucesso.")
            return conexao
        except oracledb.DatabaseError as e:
            print(f"Erro ao conectar ao banco de dados: {e}")
            return None

    conexao = conectar(usuario='rm553472',senha='100593', dsn='oracle.fiap.com.br:1521/orcl')

    # Consultar dados da tabela de feedback
    query_feedback = """
    SELECT f.id_feedback, f.id_cliente, f.id_dentista, f.id_clinica, f.avaliacao, f.comentario,
        c.nome AS nome_cliente, c.sobrenome AS sobrenome_cliente,
        d.nome AS nome_dentista, d.sobrenome AS sobrenome_dentista,
        cl.nome AS nome_clinica
    FROM Feedback f
    JOIN Cliente c ON f.id_cliente = c.id_cliente
    JOIN Dentista d ON f.id_dentista = d.id_dentista
    JOIN Clinica cl ON f.id_clinica = cl.id_clinica
    """

```

***Importante***
Não iremos apenas consumir as informações do banco de forma simples. Estamos criando um script em SQL que conterá várias Procedures, as quais se conectarão ao backend em Java e Kotlin, alimentando o banco de dados Oracle. Com essas informações, vamos agregar ao projeto para que possamos utilizar os dados da melhor maneira possível.

***O que será feito - Pandas***
Utilizaremos a biblioteca Pandas para organizar e analisar os dados dos clientes, feedbacks, clínicas e especialistas. Um exemplo simples (beta) seria tratar e dividir os dados para o treinamento do modelo de feedback, de modo a apresentar as informações ao Especialista/Médico de forma clara e organizada.

Por exemplo, um cliente pode ter avaliado a consulta com nota 5 (nota máxima), mas, no comentário, mencionou que o médico foi grosso e não deu a devida atenção que considerava necessária. Nesse caso, a nota não será mais 5, mas sim 1 ou 2, pois esse tipo de comentário carrega sentimentos negativos que podem ser melhorados. Essas notas impactarão o programa de benefícios desse especialista, e ele precisará trabalhar para melhorar sua avaliação, a fim de que novas consultas sejam direcionadas a ele.

```bash
    # Carregar dados em um DataFrame do Pandas
    df_feedback = pd.read_sql(query_feedback, conexao)

    # Fechar a conexão com o banco de dados
    conexao.close()

    # Selecionar as colunas necessárias para o treinamento do modelo de classificação de feedback
    df_feedback_model = df_feedback[['AVALIACAO', 'COMENTARIO']]

    # Exibir as primeiras linhas do DataFrame preparado para o modelo
    df_feedback_model.head()

    # Salvar o DataFrame preparado em um arquivo CSV para uso posterior pelo professor
    #df_feedback_model.to_csv('feedback_model_data.csv', index=False)

    df_feedback_model.info()

    df_feedback_model['AVALIACAO'] = df_feedback_model['AVALIACAO'].astype(int)
```

***O que será feito - Scikit-Learn***

Utilizar Scikit-Learn para classificar as clínicas e especialistas com base nas avaliações de satisfação, além de agrupar os feedbacks em categorias, sendo excelente, bons e ruins. Ajustar as notas dos feedbacks de acordos com os textos e enviar esses dados para as clínicas e especialistas, pois eles terão que trabalhar esse item para receber mais consultas.
Também utilizando este módulo, podemos agrupar os dados de produtos e indicar os melhores aos pacientes.

```bash 
    import pandas as pd
    from sklearn.model_selection import train_test_split
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.metrics import classification_report
    from sklearn.utils import resample
    import joblib

    # Carregar os dados do arquivo CSV
    #df_feedback_model = pd.read_csv('feedback_model_data.csv')

    # Converter a coluna 'avaliacao' para o tipo inteiro
    df_feedback_model['AVALIACAO'] = df_feedback_model['AVALIACAO'].astype(int)

    # Balancear o conjunto de dados
    df_majority = df_feedback_model[df_feedback_model['AVALIACAO'] == 4]
    df_minority = df_feedback_model[df_feedback_model['AVALIACAO'] == 5]

    df_minority_upsampled = resample(df_minority, 
                                    replace=True,     # sample with replacement
                                    n_samples=len(df_majority),    # to match majority class
                                    random_state=42) # reproducible results

    df_balanced = pd.concat([df_majority, df_minority_upsampled])

    # Separar os dados em recursos (X) e rótulos (y)
    X = df_balanced['COMENTARIO']
    y = df_balanced['AVALIACAO']

    # Dividir os dados em conjuntos de treinamento e teste
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Vetorização dos comentários usando TF-IDF
    vectorizer = TfidfVectorizer(stop_words='english')
    X_train_tfidf = vectorizer.fit_transform(X_train)
    X_test_tfidf = vectorizer.transform(X_test)

    # Treinar o modelo de classificação usando RandomForestClassifier com ajuste de hiperparâmetros
    model = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42)
    model.fit(X_train_tfidf, y_train)

    # Fazer previsões no conjunto de teste
    y_pred = model.predict(X_test_tfidf)

    # Exibir o relatório de classificação
    print(classification_report(y_test, y_pred))

    # Salvar o modelo treinado e o vetor de palavras para uso posterior
    joblib.dump(model, 'feedback_classification_model.pkl')
    joblib.dump(vectorizer, 'tfidf_vectorizer.pkl')
``` 

***O que será feito - Flask***

Criar uma API com Flask para fornecer as sugestões de consultas ao aplicativo. Vamos realizar testes depois do modelo treinado, para saber se ele vai localizar na base comentários ruins para evitar sugestões de atendimentos ruins.

Vamos utilizar esta API para na sessão do Médico/Especialista, conste todos os feedbacks enviados para eles, mas não os que os clientes cadastraram e sim a percepção do atendimento. Um cliente pode ter dados nota 5, mas no comentário colocou que o médico não deu os devidos detalhes, neste caso, a nota não será 5 e sim um dois ou três por exemplo. O cinco pode ter sido para clinica, mas não para o médico.

```bash
    # Instalar pip install Flask joblib scikit-learn
    from flask import Flask, request, jsonify
    import joblib
    import os

    # Carregar o modelo treinado e o vetor de palavras
    model = joblib.load('feedback_classification_model.pkl')
    vectorizer = joblib.load('tfidf_vectorizer.pkl')

    app = Flask(__name__)

    @app.route('/classificar_feedback', methods=['POST'])
    def classificar_feedback():
        dados = request.json
        comentarios = [dados['COMENTARIO']]
        
        # Vetorizar o comentário
        comentarios_tfidf = vectorizer.transform(comentarios)
        
        # Fazer a previsão
        predicao = model.predict(comentarios_tfidf)
        
        return jsonify({'AVALIACAO': int(predicao[0])})

    if __name__ == '__main__':
        port = int(os.environ.get('PORT', 6001))
        app.run(debug=True, port=port)

```

**Testar com Postman**
Teste simples para ele avaliar atendimentos 4 ou 5

```bash
    http://127.0.0.1:6001/classificar_feedback
```

No body, colocar comentários como este:
```bash
    {
    "COMENTARIO": "Excelente o atendimento"
    }

```

Resposta pode vir assim:
```bash
    {
    "AVALIACAO": 5
    }
```

***O que será feito - PyTorch***

Vamos utilizar o PyTorch para treinar um modelo de inteligência artificial que será capaz de sugerir consultas preventivas com base nos dados dos clientes. Inicialmente, desenvolvemos um modelo básico com o Scikit-Learn, mas ele não atendeu completamente às nossas necessidades, especialmente em termos de complexidade e flexibilidade no tratamento dos dados.

Para oferecer sugestões de consultas mais precisas, será necessário avaliar múltiplos fatores, incluindo a localização geográfica dos clientes e das clínicas, o que envolve a roteirização eficiente entre esses pontos. Além disso, o modelo precisará ser capaz de processar e integrar informações de várias tabelas ao mesmo tempo, analisando não apenas dados tabulares, mas também outros tipos de dados como imagens, quando necessário.

Nosso objetivo final é criar um mecanismo de recomendação que utilize IA para sugerir consultas personalizadas aos clientes de forma automática. O PyTorch se destaca por sua capacidade de lidar com modelos complexos, suportar diferentes tipos de dados (textos, imagens, etc.) e oferecer maior controle sobre a arquitetura da rede neural. Assim, ele nos permitirá desenvolver um sistema robusto e escalável para esse propósito.

Como o PyTorch pode nos ajudar?

Flexibilidade e Eficiência: Diferente do Scikit-Learn, o PyTorch oferece maior flexibilidade na construção de modelos personalizados, além de ser altamente eficiente no processamento de grandes volumes de dados.
Treinamento de Redes Neurais: Com o PyTorch, podemos construir redes neurais profundas para aprender padrões complexos a partir dos dados dos clientes, identificando as melhores sugestões de consultas com base em múltiplas variáveis.
Integração de Dados Heterogêneos: O PyTorch permite a incorporação de diferentes tipos de dados, desde tabelas relacionais até imagens e outros tipos de mídia, o que expandirá o escopo das análises e sugestões.
Suporte para Processamento Paralelo: O framework oferece suporte robusto para processamento em GPU, acelerando o treinamento de modelos, especialmente ao lidar com grandes quantidades de dados e features complexas.
Com o PyTorch, vamos além de simples análises, criando um modelo que aprende a partir de dados diversos, evolui com o tempo e fornece recomendações mais assertivas e personalizadas para cada cliente.


***O que será feito - Matplotlib***

Utilizar Matplotlib para criar gráficos que mostrem os custos e economias das consultas sugeridas. Essa informação ficará disponível no painel do cliente e das clínicas.

Deixamos um exemplo de uso dos gráficos, na pasta que se chama beta > Principal > beta-gerencial-graficos.ipynb

